r = which(sample.df[paste0('cluster.', label)] == cluster)
out[cluster] <- length(r)
temp.sd.x <- sd(sample.mat[r, paramx])
temp.sd.y <- sd(sample.mat[r, paramy])
temp.mean.x <- mean(sample.mat[r, paramx])
temp.mean.y <- mean(sample.mat[r, paramy])
if(cluster == 0){
draw.ellipse(temp.mean.x, temp.mean.y, a = temp.sd.x, b = temp.sd.y)
}else(draw.ellipse(temp.mean.x, temp.mean.y, a = temp.sd.x, b = temp.sd.y, border = flow.col[cluster]))
text(temp.mean.x, temp.mean.y, length(r))
}
legend('topleft',
legend = c(paste('Cluster', 1:k), 'Beads'),
pch = 1,
col = c(flow.col, 'black'))
## Convert to events ml^-1.  This script was originally setup to assume the beads formed a coherent and exclusive cluster, however,
## there are too often other events in this cluster, resulting in an overcount.  Now selecting based on user-defined limits, which
## should be the same as those selected for fcm_model_SG
beads.counted <- length(sample.beads)
count.cf <- beads.added / beads.counted
out[k + 1] <- beads.counted
out <- out * count.cf
out[k + 2] <- count.cf
write.csv(sample.df, sample, quote = F)
return(out)
}
pdf(paste0(output, '.clusters.pdf'))
for(sample in f.list){
cluster.tally[sample,] <- classify.fcm(sample,
som.model,
som.cluster,
paramx,
paramy,
label,
flow.col,
k,
"SSC.beads.llimit",
"FSC.beads.llimit",
"FL5.beads.llimit")
}
dev.off()
paramx <- 'SSC.HLin'
paramy <- 'GRN.B.HLin'
label <- 'sg'
sample <- f.list[1]
sample <- 'NC1.qc.csv'
som.model <- som.model
cluster.tally.df <- cluster.tally
cluster.vector <- som.cluster
SSC.beads.llimit <- 3.1
FSC.beads.llimit <- 4
FL5.beads.llimit <- 3.3
print(sample)
params <- colnames(som.model$data[[1]])
sample.df <- read.csv(sample, row.names = 1, header = T)
sample.mat <- as.matrix(sample.df[,params])
sample.mat <- log10(sample.mat)
sample.predict <- predict(som.model, sample.mat)
sample.df[paste0('cluster.', label)] <- cluster.vector[sample.predict$unit.classif]
sample.beads <- which(log10(sample.df$SSC.HLin) > SSC.beads.llimit &
log10(sample.df$BLU.V.HLin) > FL5.beads.llimit &
log10(sample.df$FSC.HLin) > FSC.beads.llimit)
10**5/20
print(sample)
params <- colnames(som.model$data[[1]])
sample.df <- read.csv(sample, row.names = 1, header = T)
sample.mat <- as.matrix(sample.df[,params])
sample.mat <- log10(sample.mat)
sample.predict <- predict(som.model, sample.mat)
sample.df[paste0('cluster.', label)] <- cluster.vector[sample.predict$unit.classif]
sample.beads <- which(log10(sample.df$SSC.HLin) > SSC.beads.llimit &
log10(sample.df$BLU.V.HLin) > FL5.beads.llimit &
log10(sample.df$FSC.HLin) > FSC.beads.llimit)
sample.df[sample.beads, paste0('cluster.', label)] <- 0
out <- vector(length = k + 2)
## regular plot
plot(sample.mat[,paramy] ~ sample.mat[,paramx],
type = 'n',
main = sample,
xlab = paramx,
ylab = paramy)
colnames(sample.mat)
sample.mat[,paramy]
sample.mat[,paramx]
plot(sample.mat[,paramy] ~ sample.mat[,paramx],
type = 'n',
main = sample,
xlab = paramx,
ylab = paramy)
for(cluster in c(0:k)){
r = which(sample.df[paste0('cluster.', label)] == cluster)
out[cluster] <- length(r)
temp.sd.x <- sd(sample.mat[r, paramx])
temp.sd.y <- sd(sample.mat[r, paramy])
temp.mean.x <- mean(sample.mat[r, paramx])
temp.mean.y <- mean(sample.mat[r, paramy])
if(cluster == 0){
draw.ellipse(temp.mean.x, temp.mean.y, a = temp.sd.x, b = temp.sd.y)
}else(draw.ellipse(temp.mean.x, temp.mean.y, a = temp.sd.x, b = temp.sd.y, border = flow.col[cluster]))
text(temp.mean.x, temp.mean.y, length(r))
}
k
temp.mean.x
r
cluster
head(sample.df)
cluster.vector[sample.predict$unit.classif]
sample.predict$unit.classif
output <- 'test_SG'                      # identifier for output files
data.path <- './'                     # make sure this ends with "/"
f.list <- list.files(path = data.path,
pattern = '*fcs',
ignore.case = F)      # list of fcs files to analyze
## Define a general plotting function for fcm data,
## takes as input plot title, dataframe, dataframe of bead events
## (can be NULL if not needed), x and y parameters.
plot.fcm <- function(name, fcm.dataframe, beads=NA, x='SSC-HLin', y='GRN-B-HLin'){
fcm.hex <- hexbin(log10(fcm.dataframe[,x]), log10(fcm.dataframe[,y]), 100)
plot(fcm.hex@xcm,
fcm.hex@ycm,
col = BTC(100)[as.numeric(cut(fcm.hex@count, 100))],
ylab = paste0('log10(', y, ')'),
xlab = paste0('log10(', x, ')'),
main = name,
pch = 19,
cex = 0.4)
try({
rect(c(min(log10(beads[,x])), min(log10(beads[,x]))),
c(min(log10(beads[,y])), min(log10(beads[,y]))),
c(max(log10(beads[,x])), max(log10(beads[,x]))),
c(max(log10(beads[,y])), max(log10(beads[,y]))))
}, silent = T)
}
#### QC parameters ####
## Lower limits for the key parameters that will be used for
## QC (assumes log10 scale).
FSC.llimit <- -0.9
SSC.llimit <- 0.1
FL1.llimit <- 0
## Lower limits for the key parameters used to
## define beads (assumes log10 scale).
SSC.beads.llimit <- 3.1
FSC.beads.llimit <- 4
FL5.beads.llimit <- 3.3
#### aggregation and QC ####
library(hexbin)
library('flowCore')
training.events <- data.frame(`FSC-HLin` = numeric(),
`SSC-HLin` = numeric(),
`GRN-B-HLin` = numeric(),
`BLU-V-HLin` = numeric()) # a dataframe to hold a selection of data for training the model
colnames(training.events) <- c("FSC-HLin", "SSC-HLin", "GRN-B-HLin", "BLU-V-HLin")
sample.size <- 1000 # size to sample from each for training data
## Iterate across all FCS files, performing QC, making plots,
## and taking a random selection of QC'd data for training.
#f.name <- f.list[25]
#grep('blank', f.list)
pdf(paste0(output, '_fcm_plots.pdf'),
width = 5,
height = 5)
for(fcs in c(f.list)){
analyze.next <- T
i <- 0
while(analyze.next == T){
i <- i + 1
fcm <- read.FCS(paste0(data.path, fcs), emptyValue = F, dataset = i)
f.name <- fcm@description$`GTI$SAMPLEID`
print(f.name)
## If it's the last record in the file, stop loop after this iteration.
if(as.integer(fcm@description$`$NEXTDATA`) == 0){
analyze.next <- F}
## Convert data to dataframe.
fcm <- as.data.frame(fcm@exprs)
fcm <- fcm[,grep('HLin', colnames(fcm))]
fcm[fcm < 1] <- NA
fcm <- na.omit(fcm)
## Identify beads.  If you don't know where the beads are start with an empty beads dataframe and
## make some plots (SSC, FL5) to identify.
fcm.beads <- data.frame()
fcm.beads <- fcm[which(log10(fcm$`SSC-HLin`) > SSC.beads.llimit &
log10(fcm$`BLU-V-HLin`) > FL5.beads.llimit &
log10(fcm$`FSC-HLin`) > FSC.beads.llimit),]
## Make plots of all events.
plot.fcm(f.name, fcm, fcm.beads, y = "FSC-HLin")
plot.fcm(f.name, fcm, fcm.beads)
## Remove events that are below limits (thresholds).
fcm <- fcm[log10(fcm$`FSC-HLin`) > FSC.llimit,]
fcm <- fcm[log10(fcm$`SSC-HLin`) > SSC.llimit,]
fcm <- fcm[log10(fcm$`GRN-B-HLin`) > FL1.llimit,]
## Make plots of only those events remaining.
plot.fcm(paste(f.name, 'QC'), fcm, fcm.beads, y = 'FSC-HLin')
plot.fcm(paste(f.name, 'QC'), fcm, fcm.beads, y = 'GRN-B-HLin')
plot.fcm(paste(f.name, 'QC'), fcm, fcm.beads, y = 'RED-V-HLin')
## blanks and other very clean samples may not have enough points to donate
## to training dataset
try({
fcm.sample <- fcm[sample(1:length(fcm[,1]), sample.size),]
training.events<- rbind(training.events, fcm.sample[,colnames(training.events)])
}, silent = T)
write.csv(fcm, paste0(f.name, '.qc.csv'), quote = F)
}
}
dev.off()
write.csv(training.events, paste0(output, '.training_events.csv'), quote = F)
training.events <- read.csv(paste0(output, '.training_events.csv'), row.names = 1)
## Define a function to train a SOM for select parameters
## from training data selected randomly during QC.
train.fcm <- function(event.file, params){
events <- read.csv(event.file, stringsAsFactors = F)
plot.fcm('training', events, NULL, x = 'SSC.HLin', y = 'FSC.HLin')
plot.fcm('training', events, NULL, x = 'SSC.HLin', y = 'GRN.B.HLin')
plot.fcm('training', events, NULL, x = 'SSC.HLin', y = 'BLU.V.HLin')
sample.mat <- as.matrix(events[,params])
colnames(sample.mat) <- params
sample.mat <- log10(sample.mat)
grid.size <- ceiling(dim(events)[1] ^ (1/2.5))
som.grid <- somgrid(xdim = grid.size, ydim = grid.size, topo="hexagonal", toroidal = T)
som.model <- som(sample.mat,
grid = som.grid,
rlen = 100,
alpha = c(0.05,0.01),
keep.data = TRUE)
return(som.model)
}
## Execute the SOM function for select parameters.
event.file <- paste0(output, '.training_events.csv')
params <- c('FSC.HLin', 'SSC.HLin', 'GRN.B.HLin')
pdf(paste0(output, '.som_model_training_plots.pdf'),
width = 5,
height = 5)
som.model <- train.fcm(event.file, params)
dev.off()
som.events <- som.model$codes[[1]]
wss <- rep(NA, 30)
for (i in 2:30) {
wss[i] <- sum(kmeans(som.events, centers=i, iter.max = 20)$withinss)
}
plot(wss,
pch = 19,
ylab = 'Within-clusters sum of squares',
xlab = 'K')
## Pick the elbow, this is the starting point for number of clusters.
k <- 6
plot.clusters <- function(alg, param, som.model, som.cluster, flow.col, j){
plot(som.model$data[[1]][,param], som.model$data[[1]][,'GRN.B.HLin'],
type = 'n',
xlab = param,
ylab = 'GRN.B.HLin',
main = paste(alg, ',', 'k =', j))
for(p in 1:j){
i <- which(som.cluster[som.model$unit.classif] == p)
points(som.model$data[[1]][i,param], som.model$data[[1]][i,'GRN.B.HLin'],
col = flow.col[p],
pch = 19,
cex = 0.4)
}
legend('topleft',
legend = paste('Cluster', 1:j),
pch = 19,
col = flow.col)
}
som.property.plot <- function(som.model, som.cluster, property, title){
plot(som.model, type = 'property', property = property, main = title)
add.cluster.boundaries(som.model, som.cluster, lwd = 2)
}
cluster.tries <- list()
pdf(paste0(output, '.cluster_eval.pdf'), width = 5, height = 5)
for(j in (k-2):(k+2)){
som.cluster.pm <- pmclust(som.events, K = j, algorithm = 'apecma')$class # model based
som.cluster.k <- kmeans(som.events, centers = j, iter.max = 100, nstart = 10)$cluster # k-means
som.dist <- vegdist(som.events) # hierarchical, step 1
som.cluster.h <- cutree(hclust(som.dist), k = j) # hierarchical, step 2
cluster.tries[[paste0('som.cluster.pm.', j)]] <- som.cluster.pm
cluster.tries[[paste0('som.cluster.k.', j)]] <- som.cluster.k
cluster.tries[[paste0('som.cluster.h.', j)]] <- som.cluster.h
flow.col <- oce.colorsFreesurface(j)
## Plots for pm.
plot.clusters('pmclust', 'SSC.HLin', som.model, som.cluster.pm, flow.col, j)
som.property.plot(som.model, som.cluster.pm, som.events[,1], paste0('log10(SSC.HLin),', 'pmclust, k =', j))
som.property.plot(som.model, som.cluster.pm, som.events[,3], paste0('log10(GRN.B.HLin),', 'pmclust, k =', j))
plot(som.model,
type = "mapping",
property = som.cluster.pm,
main = paste0('Cluster locations,', 'pmclust, k =', j),
bgcol = flow.col[som.cluster.pm],
col = NA)
## Plots for k-means.
plot.clusters('kmeans', 'SSC.HLin', som.model, som.cluster.k, flow.col, j)
som.property.plot(som.model, som.cluster.k, som.events[,1], paste0('log10(SSC.HLin),', 'kmeans, k =', j))
som.property.plot(som.model, som.cluster.k, som.events[,3], paste0('log10(GRN.B.HLin),', 'kmeans, k =', j))
plot(som.model,
type = "mapping",
property = som.cluster.k,
main = paste0('Cluster locations,', 'kmeans, k =', j),
bgcol = flow.col[som.cluster.k],
col = NA)
## Plots for hierarchical.
plot.clusters('hierarchical', 'SSC.HLin', som.model, som.cluster.h, flow.col, j)
som.property.plot(som.model, som.cluster.h, som.events[,1], paste0('log10(SSC.HLin),', 'hclust, k =', j))
som.property.plot(som.model, som.cluster.h, som.events[,3], paste0('log10(GRN.B.HLin),', 'hclust, k =', j))
plot(som.model,
type = "mapping",
property = som.cluster.h,
main = paste0('Cluster locations,', 'hclust, k =', j),
bgcol = flow.col[som.cluster.h],
col = NA)
}
dev.off()
k <- 4
cluster.method <- 'k' #either k, pm, or h
som.cluster <- cluster.tries[[paste('som.cluster', cluster.method, k, sep = '.')]]
cluster.notes <- paste(cluster.method, 'k=', k)
save(list = c('som.model', 'som.cluster', 'k', 'cluster.notes'), file = paste0(output, '.som.Rdata'))
f.list <- list.files(path = '.', pattern = '.qc.csv', ignore.case = T)
output <- 'test.sg'
input <- 'test_SG.som.Rdata'
label <- 'sg'
paramx <- 'SSC.HLin' # SSC best indicator for size, pg. 422 "In Living Color"?
paramy <- 'GRN.B.HLin'
beads.added <- 0.5 * 10^4 # 50 ul of 10^5 per ml
load(input)
cluster.tally <- matrix(nrow = length(f.list), ncol = k + 2)
colnames(cluster.tally) <- c(1:k, 'beads', 'correction_factor_applied')
row.names(cluster.tally) <- f.list
flow.col <- oce.colorsFreesurface(k)
classify.fcm <- function(sample,
som.model,
cluster.vector,
paramx,
paramy,
label,
flow.col,
k,
SSC.beads.llimit,
FSC.beads.llimit,
FL5.beads.llimit){
print(sample)
params <- colnames(som.model$data[[1]])
sample.df <- read.csv(sample, row.names = 1, header = T)
sample.mat <- as.matrix(sample.df[,params])
sample.mat <- log10(sample.mat)
sample.predict <- predict(som.model, sample.mat)
sample.df[paste0('cluster.', label)] <- cluster.vector[sample.predict$unit.classif]
sample.beads <- which(log10(sample.df$SSC.HLin) > SSC.beads.llimit &
log10(sample.df$BLU.V.HLin) > FL5.beads.llimit &
log10(sample.df$FSC.HLin) > FSC.beads.llimit)
## beads are assigned cluster 0
sample.df[sample.beads, paste0('cluster.', label)] <- 0
out <- vector(length = k + 2)
## regular plot
plot(sample.mat[,paramy] ~ sample.mat[,paramx],
type = 'n',
main = sample,
xlab = paramx,
ylab = paramy)
for(cluster in c(0:k)){
r = which(sample.df[paste0('cluster.', label)] == cluster)
out[cluster] <- length(r)
temp.sd.x <- sd(sample.mat[r, paramx])
temp.sd.y <- sd(sample.mat[r, paramy])
temp.mean.x <- mean(sample.mat[r, paramx])
temp.mean.y <- mean(sample.mat[r, paramy])
if(cluster == 0){
draw.ellipse(temp.mean.x, temp.mean.y, a = temp.sd.x, b = temp.sd.y)
}else(draw.ellipse(temp.mean.x, temp.mean.y, a = temp.sd.x, b = temp.sd.y, border = flow.col[cluster]))
text(temp.mean.x, temp.mean.y, length(r))
}
legend('topleft',
legend = c(paste('Cluster', 1:k), 'Beads'),
pch = 1,
col = c(flow.col, 'black'))
## Convert to events ml^-1.  This script was originally setup to assume the beads formed a coherent and exclusive cluster, however,
## there are too often other events in this cluster, resulting in an overcount.  Now selecting based on user-defined limits, which
## should be the same as those selected for fcm_model_SG
beads.counted <- length(sample.beads)
count.cf <- beads.added / beads.counted
out[k + 1] <- beads.counted
out <- out * count.cf
out[k + 2] <- count.cf
write.csv(sample.df, sample, quote = F)
return(out)
}
pdf(paste0(output, '.clusters.pdf'))
for(sample in f.list){
cluster.tally[sample,] <- classify.fcm(sample,
som.model,
som.cluster,
paramx,
paramy,
label,
flow.col,
k,
"SSC.beads.llimit",
"FSC.beads.llimit",
"FL5.beads.llimit")
}
dev.off()
View(cluster.tally)
paramx <- 'SSC.HLin'
paramy <- 'GRN.B.HLin'
label <- 'sg'
sample <- f.list[1]
sample <- 'NC1.qc.csv'
som.model <- som.model
cluster.tally.df <- cluster.tally
cluster.vector <- som.cluster
SSC.beads.llimit <- 3.1
FSC.beads.llimit <- 4
FL5.beads.llimit <- 3.3
cluster.tally
cluster.tally <- matrix(nrow = length(f.list), ncol = k + 2)
colnames(cluster.tally) <- c(1:k, 'beads', 'correction_factor_applied')
row.names(cluster.tally) <- f.list
som.cluster
print(sample)
params <- colnames(som.model$data[[1]])
params
cluster.tally.df <- cluster.tally
sample.df <- read.csv(sample, row.names = 1, header = T)
sample.mat <- as.matrix(sample.df[,params])
sample.mat <- log10(sample.mat)
head(sample.mat)
sample.predict <- predict(som.model, sample.mat)
sample.df[paste0('cluster.', label)] <- cluster.vector[sample.predict$unit.classif]
head(sample.df)
sample.beads <- which(log10(sample.df$SSC.HLin) > SSC.beads.llimit &
log10(sample.df$BLU.V.HLin) > FL5.beads.llimit &
log10(sample.df$FSC.HLin) > FSC.beads.llimit)
## beads are assigned cluster 0
sample.df[sample.beads, paste0('cluster.', label)] <- 0
out <- vector(length = k + 2)
for(cluster in c(0:k)){
r = which(sample.df[paste0('cluster.', label)] == cluster)
out[cluster] <- length(r)
temp.sd.x <- sd(sample.mat[r, paramx])
temp.sd.y <- sd(sample.mat[r, paramy])
temp.mean.x <- mean(sample.mat[r, paramx])
temp.mean.y <- mean(sample.mat[r, paramy])
if(cluster == 0){
draw.ellipse(temp.mean.x, temp.mean.y, a = temp.sd.x, b = temp.sd.y)
}else(draw.ellipse(temp.mean.x, temp.mean.y, a = temp.sd.x, b = temp.sd.y, border = flow.col[cluster]))
text(temp.mean.x, temp.mean.y, length(r))
}
plot(sample.mat[,paramy] ~ sample.mat[,paramx],
type = 'n',
main = sample,
xlab = paramx,
ylab = paramy)
for(cluster in c(0:k)){
r = which(sample.df[paste0('cluster.', label)] == cluster)
out[cluster] <- length(r)
temp.sd.x <- sd(sample.mat[r, paramx])
temp.sd.y <- sd(sample.mat[r, paramy])
temp.mean.x <- mean(sample.mat[r, paramx])
temp.mean.y <- mean(sample.mat[r, paramy])
if(cluster == 0){
draw.ellipse(temp.mean.x, temp.mean.y, a = temp.sd.x, b = temp.sd.y)
}else(draw.ellipse(temp.mean.x, temp.mean.y, a = temp.sd.x, b = temp.sd.y, border = flow.col[cluster]))
text(temp.mean.x, temp.mean.y, length(r))
}
legend('topleft',
legend = c(paste('Cluster', 1:k), 'Beads'),
pch = 1,
col = c(flow.col, 'black'))
beads.added
beads.counted
beads.counted <- length(sample.beads)
count.cf <- beads.added / beads.counted
out[k + 1] <- beads.counted
out <- out * count.cf
out[k + 2] <- count.cf
out
sample
classify.fcm(sample,
som.model,
som.cluster,
paramx,
paramy,
label,
flow.col,
k,
"SSC.beads.llimit",
"FSC.beads.llimit",
"FL5.beads.llimit")
classify.fcm(sample,
som.model,
som.cluster,
paramx,
paramy,
label,
flow.col,
k,
SSC.beads.llimit,
FSC.beads.llimit,
FL5.beads.llimit)
pdf(paste0(output, '.clusters.pdf'))
for(sample in f.list){
cluster.tally[sample,] <- classify.fcm(sample,
som.model,
som.cluster,
paramx,
paramy,
label,
flow.col,
k,
SSC.beads.llimit,
FSC.beads.llimit,
FL5.beads.llimit)
}
dev.off()
write.csv(cluster.tally, paste0(output, '.cluster.tally.csv'), quote = F)
2499.98-1452
